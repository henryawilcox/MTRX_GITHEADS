/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include "timer.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


void enable_clocks(void);
void initialise_board(void);

// Example callback
void blink_leds(void) {
    static uint8_t led_state = 0;
    uint8_t *led_output = ((uint8_t *)&(GPIOE->ODR)) + 1;
    *led_output = led_state ? 0b01010101 : 0x00;
    led_state = !led_state;
}


// enable the clocks for desired peripherals (GPIOA, C and E)
void enable_clocks() {

	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;

	/*
	@ enable the clocks for peripherals (GPIOA, C and E)
	LDR R0, =RCC  @ load the address of the RCC address boundary (for enabling the IO clock)
	LDR R1, [R0, #AHBENR]  @ load the current value of the peripheral clock registers
	ORR R1, 1 << GPIOA_ENABLE | 1 << GPIOC_ENABLE | 1 << GPIOE_ENABLE  @ 21st bit is enable GPIOE clock, 17 is GPIOA clock
	STR R1, [R0, #AHBENR]  @ store the modified register back to the submodule
	BX LR @ return from function call
	*/


	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	/*
	LDR R0, =RCC	@ load the base address for the timer
	LDR R1, [R0, APB1ENR] 	@ load the peripheral clock control register
	ORR R1, 1 << TIM2EN @ store a 1 in bit for the TIM2 enable flag
	STR R1, [R0, APB1ENR] @ enable the timer
	BX LR @ return
	*/
}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board() {

	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
	*led_output_registers = 0x5555;

	/*
	LDR R0, =GPIOE 	@ load the address of the GPIOE register into R0
	LDR R1, =0x5555 @ load the binary value of 01 (OUTPUT) for each port in the upper two bytes
					@ as 0x5555 = 01010101 01010101
	STRH R1, [R0, #MODER + 2]   @ store the new register values in the top half word representing
								@ the MODER settings for pe8-15
	BX LR @ return from function call
	*/
}


void trigger_prescaler() {

	TIM2->ARR = 0x01;
	TIM2->CNT = 0x00;
	asm("NOP");
	asm("NOP");
	asm("NOP");
	TIM2->ARR = 1000;
	/*
	@ Use (TIMx_EGR) instead (to reset the clock)

	@ This is a hack to get the prescaler to take affect
	@ the prescaler is not changed until the counter overflows
	@ the TIMx_ARR register sets the count at which the overflow
	@ happens. Here, the reset is triggered and the overflow
	@ occurs to make the prescaler take effect.

	@ In your code, you should be using the ARR register to
	@ set the maximum count for the timer

	@ store a value for the prescaler
	LDR R0, =TIM2	@ load the base address for the timer

	LDR R1, =0x1 @ make the timer overflow after counting to only 1
	STR R1, [R0, TIM_ARR] @ set the ARR register

	LDR R8, =0x00
	STR R8, [R0, TIM_CNT] @ reset the clock
	NOP
	NOP

	LDR R1, =0xffffffff @ set the ARR back to the default value
	STR R1, [R0, TIM_ARR] @ set the ARR register

	BX LR
	*/
}



//  general purpose timer registers page 647
void periodicBlink(void) {
    static uint8_t led_state = 0;
    uint8_t *led_output = ((uint8_t *)&(GPIOE->ODR)) + 1;
    *led_output = led_state ? 0xAA : 0x00;  // 0xAA = 10101010
    led_state = !led_state;
}

void oneShotBlink(void) {
    uint8_t *led_output = ((uint8_t *)&(GPIOE->ODR)) + 1;
    *led_output = 0xFF;  // Turn all on briefly
    for (volatile int i = 0; i < 1000000; i++);  // Delay
    *led_output = 0x00;
}

int main(void) {
    enable_clocks();
    initialise_board();

    //Timer_Init(1000, periodicBlink); // Blink every 1000ms
    //Timer_Start();                   // Loop forever

    // Or trigger a one-shot event:
    Timer_StartOneShot(2000, oneShotBlink); // Trigger once after 2 seconds
}

