/*
 * serial_interrupt.c
 *
 *  Created on: Apr 13, 2025
 *      Author: henrywilcox
 */

#include "serial.h"
#include "serial_interrupts.h"

#include "stm32f303xc.h"

// Flag to indicate if a complete string has been received
volatile uint8_t string_complete = 0;
// Index for storing characters in the buffer



void EnableSerialInterrupts(SerialPort *serial_port) {
    // Disable interrupts while setting up
    __disable_irq();

    // Reset buffer
        for (int i = 0; i < BUFFER_SIZE; i++) {
               serial_port->rx_buffer[i] = 0;
           }

    // Enable RXNE interrupt
    serial_port->UART->CR1 |= USART_CR1_RXNEIE;

    // Enable the USART1 interrupt in NVIC (assuming USART1)
    NVIC_EnableIRQ(USART1_IRQn);
    NVIC_SetPriority(USART1_IRQn, 0);

    // Re-enable interrupts
    __enable_irq();
}

// USART1 interrupt handler
void USART1_IRQHandler(void) {
    // Check if we received data
    uint8_t rx_index = 0; //

	if (USART1->ISR & USART_ISR_RXNE) {
        // Read the received data
        uint8_t received_char = USART1->RDR;

        // Check for overrun or framing error
        if (USART1->ISR & (USART_ISR_ORE | USART_ISR_FE)) {
            USART1->ICR |= USART_ICR_ORECF | USART_ICR_FECF;
        }

        // Store the character if there's space in the buffer
        if (rx_index < BUFFER_SIZE - 1) {
            // Store character in buffer
            USART1_PORT.rx_buffer[rx_index++] = received_char;

            // Check if terminating character received
            if (received_char == '\r' || rx_index >= BUFFER_SIZE - 1) {
                // Null-terminate the string
                USART1_PORT.rx_buffer[rx_index] = '\0';
                //store for callback
                USART1_PORT.completion_function(serial_port->rx_buffer, (uint8_t)rx_index);


            }
        } else {
            rx_index = 0;
        }
    }
}

